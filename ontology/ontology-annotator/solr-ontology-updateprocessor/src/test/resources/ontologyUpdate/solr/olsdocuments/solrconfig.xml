<?xml version="1.0" encoding="UTF-8" ?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<!-- 
     For more details about configurations options that may appear in
     this file, see http://wiki.apache.org/solr/SolrConfigXml. 
-->
<config>
    <!-- In all configuration below, a prefix of "solr." for class names
         is an alias that causes solr to search appropriate packages,
         including org.apache.solr.(search|update|request|core|analysis)

         You may also specify a fully qualified Java classname if you
         have your own custom plugins.
      -->

    <!-- Controls what version of Lucene various components of Solr
         adhere to.  Generally, you want to use the latest version to
         get all bug fixes and improvements. It is highly recommended
         that you fully re-index after changing this setting as it can
         affect both how text is indexed and queried.
    -->
    <luceneMatchVersion>5.0.0</luceneMatchVersion>

    <!-- Data Directory

         Used to specify an alternate directory to hold all index data
         other than the default ./data under the Solr home.  If
         replication is in use, this should match the replication
         configuration.
      -->
    <dataDir>${solr.data.dir:}</dataDir>


    <!-- The DirectoryFactory to use for indexes.

         solr.StandardDirectoryFactory is filesystem
         based and tries to pick the best implementation for the current
         JVM and platform.  solr.NRTCachingDirectoryFactory, the default,
         wraps solr.StandardDirectoryFactory and caches small files in memory
         for better NRT performance.

         One can force a particular implementation via solr.MMapDirectoryFactory,
         solr.NIOFSDirectoryFactory, or solr.SimpleFSDirectoryFactory.

         solr.RAMDirectoryFactory is memory based, not
         persistent, and doesn't work with replication.
      -->
    <directoryFactory name="DirectoryFactory"
                      class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}">

    </directoryFactory>

    <!-- The CodecFactory for defining the format of the inverted index.
         The default implementation is SchemaCodecFactory, which is the official Lucene
         index format, but hooks into the schema to provide per-field customization of
         the postings lists and per-document values in the fieldType element
         (postingsFormat/docValuesFormat). Note that most of the alternative implementations
         are experimental, so if you choose to customize the index format, its a good
         idea to convert back to the official format e.g. via IndexWriter.addIndexes(IndexReader)
         before upgrading to a newer version to avoid unnecessary reindexing.
    -->
    <codecFactory class="solr.SchemaCodecFactory"/>

    <schemaFactory class="ClassicIndexSchemaFactory"/>

    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         Index Config - These settings control low-level behavior of indexing
         Most example settings here show the default value, but are commented
         out, to more easily see where customizations have been made.

         Note: This replaces <indexDefaults> and <mainIndex> from older versions
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <indexConfig>
        <lockType>${solr.lock.type:native}</lockType>

        <!-- Lucene Infostream

             To aid in advanced debugging, Lucene provides an "InfoStream"
             of detailed information when indexing.

             Setting the value to true will instruct the underlying Lucene
             IndexWriter to write its info stream to solr's log. By default,
             this is enabled here, and controlled through log4j.properties.
          -->
        <infoStream>true</infoStream>
    </indexConfig>

    <!-- The default high-performance update handler -->
    <updateHandler class="solr.DirectUpdateHandler2">

        <updateLog enable="${enable.update.log:true}">
            <str name="dir">${solr.ulog.dir:}</str>
        </updateLog>

        <autoCommit>
            <maxTime>${solr.autoCommit.maxTime:15000}</maxTime>
            <openSearcher>false</openSearcher>
        </autoCommit>

        <autoSoftCommit>
            <maxTime>${solr.autoSoftCommit.maxTime:-1}</maxTime>
        </autoSoftCommit>

    </updateHandler>

    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         Query section - these settings control query time things like caches
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <query>
        <maxBooleanClauses>1024</maxBooleanClauses>

        <filterCache class="solr.FastLRUCache"
                     size="512"
                     initialSize="512"
                     autowarmCount="0"/>

        <queryResultCache class="solr.LRUCache"
                          size="512"
                          initialSize="512"
                          autowarmCount="0"/>

        <documentCache class="solr.LRUCache"
                       size="512"
                       initialSize="512"
                       autowarmCount="0"/>

        <!-- custom cache currently used by block join -->
        <cache name="perSegFilter"
               class="solr.search.LRUCache"
               size="10"
               initialSize="0"
               autowarmCount="10"
               regenerator="solr.NoOpRegenerator"/>

        <enableLazyFieldLoading>true</enableLazyFieldLoading>

        <queryResultWindowSize>20</queryResultWindowSize>

        <!-- Maximum number of documents to cache for any entry in the
             queryResultCache.
          -->
        <queryResultMaxDocsCached>200</queryResultMaxDocsCached>

        <!-- QuerySenderListener takes an array of NamedList and executes a
             local query request for each NamedList in sequence.
          -->
        <listener event="newSearcher" class="solr.QuerySenderListener">
            <arr name="queries">
                <!--
                   <lst><str name="q">solr</str><str name="sort">price asc</str></lst>
                   <lst><str name="q">rocks</str><str name="sort">weight asc</str></lst>
                  -->
            </arr>
        </listener>
        <listener event="firstSearcher" class="solr.QuerySenderListener">
            <arr name="queries">
                <lst>
                    <str name="q">static firstSearcher warming in solrconfig.xml</str>
                </lst>
            </arr>
        </listener>

        <useColdSearcher>false</useColdSearcher>

        <maxWarmingSearchers>2</maxWarmingSearchers>

    </query>

    <!-- Request Dispatcher -->
    <requestDispatcher handleSelect="false">
        <requestParsers enableRemoteStreaming="true"
                        multipartUploadLimitInKB="2048000"
                        formdataUploadLimitInKB="2048"
                        addHttpRequestToContext="false"/>

        <httpCaching never304="true"/>
    </requestDispatcher>

    <!-- Request Handlers

         http://wiki.apache.org/solr/SolrRequestHandler

         Incoming queries will be dispatched to a specific handler by name
         based on the path specified in the request.

         Legacy behavior: If the request path uses "/select" but no Request
         Handler has that name, and if handleSelect="true" has been specified in
         the requestDispatcher, then the Request Handler is dispatched based on
         the qt parameter.  Handlers without a leading '/' are accessed this way
         like so: http://host/app/[core/]select?qt=name  If no qt is
         given, then the requestHandler that declares default="true" will be
         used or the one named "standard".

         If a Request Handler is declared with startup="lazy", then it will
         not be initialized until the first request that uses it.

         The "standard" request handler is the default and will be used if qt
         is not specified in the request.
      -->
    <requestHandler name="/select" class="solr.SearchHandler">
        <!-- default values for query parameters can be specified, these
             will be overridden by parameters in the request
          -->
        <lst name="defaults">
            <str name="echoParams">explicit</str>
            <int name="rows">10</int>
            <str name="df">text</str>
        </lst>
    </requestHandler>

    <requestHandler name="standard" class="solr.StandardRequestHandler">
        <bool name="httpCaching">true</bool>
    </requestHandler>

    <!-- Ontology lookup processor chain -->
    <updateRequestProcessorChain name="ontology">
        <processor class="uk.co.flax.biosolr.solr.update.processor.OntologyUpdateProcessorFactory">
            <bool name="enabled">true</bool>
            <str name="annotationField">annotation_uri</str>
            <str name="labelField">ontology_label</str>

            <!-- Location of the ontology -->
            <str name="olsBaseURL">http://www.ebi.ac.uk/ols/beta/api</str>
            <str name="olsOntology">efo</str>

            <!-- Exclude indirect relations -->
            <bool name="includeIndirect">false</bool>
        </processor>
        <processor class="solr.RunUpdateProcessorFactory"/>
    </updateRequestProcessorChain>

    <queryResponseWriter name="json" class="solr.JSONResponseWriter">
        <!-- For the purposes of the tutorial, JSON responses are written as
         plain text so that they are easy to read in *any* browser.
         If you expect a MIME type of "application/json" just remove this override.
        -->
        <str name="content-type">text/plain; charset=UTF-8</str>
    </queryResponseWriter>

</config>  